//-----------------------------------------------------------------------------------------------------
//  Sourse      : FileName.cpp
//  Created     : 01.06.2022
//  Author      : Alexandr Volvenkin
//  email       : aav-36@mail.ru
//  GitHub      : https://github.com/AlexandrVolvenkin
//-----------------------------------------------------------------------------------------------------
#include "DiscreteInput.h"
#include "Platform.h"

//-----------------------------------------------------------------------------------------------------
CDiscreteInput::CDiscreteInput()
{
    //ctor
}

//-----------------------------------------------------------------------------------------------------
CDiscreteInput::~CDiscreteInput()
{
    //dtor
}

//-----------------------------------------------------------------------------------------------------
CDiscreteInputDriver::CDiscreteInputDriver()
{
    //ctor
}

//-----------------------------------------------------------------------------------------------------
CDiscreteInputDriver::~CDiscreteInputDriver()
{
    //dtor
}

//-----------------------------------------------------------------------------------------------------
CModbusDiscreteInputDriver::CModbusDiscreteInputDriver()
{
    //ctor
}

//-----------------------------------------------------------------------------------------------------
CModbusDiscreteInputDriver::~CModbusDiscreteInputDriver()
{
    //dtor
}


//-----------------------------------------------------------------------------------------------------
void CMvsn21Driver::Init(void)
{

}

//-----------------------------------------------------------------------------------------------------
void CMvsn21Driver::Allocate(TMemoryAllocationConext &xMemoryAllocationConext)
{
    m_uiAddress = xMemoryAllocationConext.uiAddress;
    m_puiRxBuffer = xMemoryAllocationConext.puiRxBuffer;
    m_puiTxBuffer = xMemoryAllocationConext.puiTxBuffer;
    // Получим указатель на место в массиве дискретных входов для текущего модуля.
    m_puiDiscreteInputs =
        &xMemoryAllocationConext.
        puiDiscreteInputs[xMemoryAllocationConext.uiUsedDiscreteInputs];
    // Увеличим общий объём выделенной памяти.
    xMemoryAllocationConext.
    uiUsedDiscreteInputs +=
        MVSN21_DISCRETE_INPUTS_NUMBER;
}

//-----------------------------------------------------------------------------------------------------
uint16_t CMvsn21Driver::ReportType(uint8_t *puiDestination, uint16_t uiLength)
{
    memset(m_puiTxBuffer, 0, 4);
    uint8_t uiLengthLocal = 0;
    m_puiTxBuffer[uiLengthLocal++] = GET_MODULE_TYPE_COMMAND;
    m_puiTxBuffer[uiLengthLocal++] = 0;
    m_puiTxBuffer[uiLengthLocal++] = 0;
    m_puiTxBuffer[uiLengthLocal++] = 0;
    m_puiTxBuffer[uiLengthLocal++] = 0;
//    m_auiSpiTxBuffer[uiLengthLocal] = iCrcSummOneByteCalculation(m_auiSpiTxBuffer,
//                                    uiLengthLocal);
//    // Размер сообщения на один больше, чтобы принять последний байт.
//    uiLengthLocal++;
    CPss21::ConnectDevice(m_uiAddress);
    delay_us(500);
    CSpi::Exchange(m_puiRxBuffer, m_puiTxBuffer, uiLengthLocal);
    CPss21::DisconnectDevice();
}

//-----------------------------------------------------------------------------------------------------
uint8_t CMvsn21Driver::DataExchange(void)
{
    m_puiTxBuffer[0] = DATA_EXCHANGE_COMMAND;
    CPss21::ConnectDevice(m_uiAddress);
    delay_us(500);
    CSpi::Exchange(m_puiRxBuffer,
                   m_puiTxBuffer,
                   (SPI_PRIAMBLE_LENGTH +
                    DATA_EXCHANGE_COMMAND_ANSWER_LENGTH +
                    ONE_BYTE_CRC_LENGTH));
    CPss21::DisconnectDevice();

    // модуль исправен?
    if (m_puiRxBuffer[SPI_COMMAND_BYTE_OFFSET] == DATA_EXCHANGE_COMMAND)
    {
//        // данные не повреждены?
//        //debag//if ((iCrcSummOneByteCompare(&m_puiRxBuffer[SPI_DATA_BYTE_OFFSET],
//                                    (DATA_EXCHANGE_COMMAND_ANSWER_LENGTH +
//                                     ONE_BYTE_CRC_LENGTH)) > 0) &&
//                ((m_puiRxBuffer[SPI_DATA_BYTE_OFFSET +
//                                DATA_EXCHANGE_COMMAND_ANSWER_LENGTH]) != 0))
        if ((iCrcSummOneByteCompare(&m_puiRxBuffer[SPI_DATA_BYTE_OFFSET],
                                    DATA_EXCHANGE_COMMAND_ANSWER_LENGTH) > 0))
        {
            // что ответил модуль?
            switch(m_puiRxBuffer[SPI_COMMAND_BYTE_OFFSET])
            {
            case DATA_READY:
                // отправим полученные от модуля данные в рабочий массив прибора.
                uint8_t *puiDestination = m_puiDiscreteInputs;
                for (uint8_t i = 0; i < DISCRETE_INPUT_BYTE_QUANTITY; i++)
                {
                    uint8_t uiData = (m_puiRxBuffer[i + SPI_DATA_BYTE_OFFSET]);

                    for (uint8_t j = 0; j < DISCRETE_INPUT_BITS_IN_BYTE_QUANTITY; j++)
                    {
                        // четные биты (D0,D2,D4,D6) = 0 - разомкнуто (OFF), = 1 - замкнуто (ON)
                        // нечетные биты (D1,D3,D5,D7) = 0 - достоверно, = 1 - недостоверно
                        // бит нечётный?
                        if (j & 0x01)
                        {
                            //                            // бит достоверен? 0 - достоверно, 1 - недостоверно.
//                            *pucDestination2++ = ((ucData & (1 << j)) ? 1 : 0);
                        }
                        else
                        {
                            //контакты замкнуты?  0 - разомкнуто (OFF), 1 - замкнуто (ON)
                            if ((uiData & (1 << j)))
                            {
                                *puiDestination++ = 1;
                            }
                            else
                            {
                                *puiDestination++ = 0;
                            }
                        }
                    }
                }
                break;

            case DATA_NOT_READY:
                break;

            default:
                break;
            };
            return 0;
        }
    }
}
